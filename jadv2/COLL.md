# Коллекции для параллельной работы

## Задача 1 (обязательная)

Эта задача делается на основе предыдущей про красивые строки. Сделайте от того решения новую ветку `queue`.

Раньше вы сперва генерировали все строки, сохраняли их все в память и только после этого считали количество красивых.
Теперь вы хотите распараллелить этап создания строк и этапы анализа их красивости.
Для этого у вас строки будут генерироваться в отдельном потоке и заполнять блокирующие очереди, максимальный размер которых ограничьте в 100 строк.
Очереди нужно будет сделать по одной для каждого критерия, тк строка должна быть обработана каждым потоком, определяющим их красивость.

Подсказка: воспользуйтесь `ArrayBlockingQueue`.

В итоге:
1. Создайте в статических полях три потокобезопасные блокирующие очереди
2. Создайте поток, который наполнял бы их текстами
3. Создайте по потоку для каждого критерия красивости, которые разбирали бы свою очередь и делали бы подсчёты

На проверку отправьте ссылку на ветку `queue` в вашем репозиториии с решением.

## Задача 2 (необязательная)

Эта задача делается на основе [первой задачи про синхронизацию](../SYNC.md).
Отведите от вашего её решения новую ветку `multimap`.

Замените `HashMap` на потокобезопасную мапу, избавьтесь от лишней синхронизации.

В итоге:
1. Заменяете `HashMap` на выбранную вами потокобезопасную мапу
2. Смотрите какие ганантии даёт эта мапа, убираете `synchronized` с тех секций, в которых он с такой мапой оказывается излишним

На проверку отправьте ссылку на ветку `multimap` в вашем репозиториии с решением.
