# Работа с синхронизацией

## Задача 1 (обязательная)
Возьмите первую задачу с прошлого домашнего задания. Отведите от неё ветку `freqs` для решения этой задачи.

Запустив программу, вы обратили внимание, что размеры промежутков с буквой 'a' часто повторяются и вам стало интересно, какие размеры попадаются чаще всего.

Для этого вы завели мапу (`HashMap`) в статическом поле `public static final Map<Integer, Integer> sizeToFreq`, которая после завершения потоков должна хранить в ключах попавшиеся размеры. а в значениях - количество раз сколько они попались.
В итоге, обработав каждую строку, вам нужно будет обновить эту мапу, увеличив значение для полученного размера в ней на 1 (а если размера в мапе не было - просто вставить значение 1).

Однако возникает проблема - `HashMap` не потокобезопасна, нельзя к ней обращаться из разных потоков "одновременно".
Решением этой проблемы будет использование блока синхронизации (`synchronized`).

Реализуйте этот функционал, в конце основного потока выведите сообщение вида:
```text
Самый частый размер 31 (встретился 9 раз)
Другие размеры:
- 30 (5 раз)
- 34 (3 раз)
- 32 (6 раз)
...
```

В итоге:
1. Заведите `HashMap` в статическом поле `public static final Map<Integer, Integer> sizeToFreq`
2. При обработке каждой строки увеличьте счётчик в мапе
3. Используйте synchronized для потокобезопасного доступа к мапе

На проверку отправьте ссылку на ветку `freqs` в вашем репозиториии с решением.

## Задача 2 (обязательная)
Эта задача делается на основе первой задачи этого домашнего задания. Отведите новую ветку `freqlog` от `freqs`.

Теперь вы хотите чтобы каждый раз когда обновляется мапа `sizeToFreq` на экран выводился бы текущий лидер среди размеров.
Для этого придётся пробегаться целиком по всей мапе в поисках лидера, что достаточно затратно.

Вместо того чтобы делать это в том же потоке, что и считал размер, заведите один отдельный поток, который будет заниматься только подсчётом максимума в мапе и выводом этой информации на экран.
Делать он это будет в цикле, а чтобы подсчёт и вывод делался только когда нужно, он будет ждать "сигнала" через wait-notify от считающих потоков.
Условием цикла поставьте проверку на то что поток не прервали. В основном потоке после for с join прервите этот выводящий максимумы поток.

В итоге:
1. Создайте отдельный поток для вывода на экран лидера в частотной мапе
2. В этом потоке должен быть бесконечный цикл с проверкой на прерванность `while (!Thread.interrupted()) { ... }`
3. В цикле перед каждым поиском и выводом на экран максимума в мапе поток должен ждать сигнала от заполняющих мапу потоков
4. В заполняющих мапу потоках добавьте отправку сигнала печатающему максимумы потоку
5. После завершения всех считающих потоков прервите печатающий поток через `thread.interrupt()`

На проверку отправьте ссылку на ветку `freqlog` в вашем репозиториии с решением.
