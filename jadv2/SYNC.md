# Работа с синхронизацией

## Задача 1 (обязательная)
Возьмём функцию генерацию текста из букв строки, переданной первым параметром:
```java
    public static String generateText(String letters, int length) {
        Random random = new Random();
        StringBuilder text = new StringBuilder();
        for (int i = 0; i < length; i++) {
            text.append(letters.charAt(random.nextInt(letters.length())));
        }
        return text.toString();
    }
```

Напишите многопоточную программу, которая в каждом потоке генерирует текст: `generateText("abaca", 100)`, считает количество буквы 'a' и вывыодить на экран. Количество потоков (= генерируемых текстов) пусть будет 1000.

Так как буква 'a' в параметре генератора упомянута три раза из пяти, то в среднем, количество букв 'a' должно быть 60% от всех букв, т.е. где-то около 60. Однако, тк процесс вероятностный, точное количество раз которое встретится эта буква в каждом тексте может немного отклоняться от среднего значения.

Запустив программу, вы обратили внимание, что размеры промежутков с буквой 'a' часто повторяются и вам стало интересно, какие размеры попадаются чаще всего.

Для этого вы завели мапу (`HashMap`) в статическом поле `public static final Map<Integer, Integer> sizeToFreq`, которая после завершения потоков должна хранить в ключах попавшиеся частоты буквы 'a', а в значениях - количество раз сколько они попались.
В итоге, обработав каждую строку, вам нужно будет обновить эту мапу, увеличив значение для полученной частоты в ней на 1 (а если частоты в мапе не было - просто вставить значение 1).

Однако возникает проблема - `HashMap` не потокобезопасна, нельзя к ней обращаться из разных потоков "одновременно".
Решением этой проблемы будет использование блока синхронизации (`synchronized`).

Реализуйте этот функционал, в конце основного потока выведите сообщение вида:
```text
Самая частая частота 61 (встретился 9 раз)
Другие размеры:
- 60 (5 раз)
- 64 (3 раз)
- 62 (6 раз)
...
```

В итоге:
1. Заведите `HashMap` в статическом поле `public static final Map<Integer, Integer> sizeToFreq`
2. При обработке каждой строки увеличьте счётчик в мапе
3. Используйте synchronized для потокобезопасного доступа к мапе

На проверку отправьте ссылку на репозиторий с решением с решением.

## Задача 2 (обязательная)
Эта задача делается на основе первой задачи этого домашнего задания. Отведите новую ветку `freqlog`.

Теперь вы хотите чтобы каждый раз когда обновляется мапа `sizeToFreq` на экран выводился бы текущий лидер среди частот.
Для этого придётся пробегаться целиком по всей мапе в поисках лидера, что достаточно затратно.

Вместо того чтобы делать это в том же потоке, что и считал размер, заведите один отдельный поток, который будет заниматься только подсчётом максимума в мапе и выводом этой информации на экран.
Делать он это будет в цикле, а чтобы подсчёт и вывод делался только когда нужно, он будет ждать "сигнала" через wait-notify от считающих потоков.
Условием цикла поставьте проверку на то что поток не прервали. В основном потоке после for с join прервите этот выводящий максимумы поток.

В итоге:
1. Создайте отдельный поток для вывода на экран лидера в частотной мапе
2. В этом потоке должен быть бесконечный цикл с проверкой на прерванность `while (!Thread.interrupted()) { ... }`
3. В цикле перед каждым поиском и выводом на экран максимума в мапе поток должен ждать сигнала от заполняющих мапу потоков
4. В заполняющих мапу потоках добавьте отправку сигнала печатающему максимумы потоку
5. После завершения всех считающих потоков прервите печатающий поток через `thread.interrupt()`

На проверку отправьте ссылку на ветку `freqlog` в вашем репозиториии с решением.
